

typedef boost::make_recursive_variant<int, std::vector< boost::recursive_variant_ >>::type int_tree_t;
Use of the resultant variant type is as expected:
std::vector< int_tree_t > subresult;
subresult.push_back(3);
subresult.push_back(5);

std::vector< int_tree_t > result;
result.push_back(1);
result.push_back(subresult);
result.push_back(7);

int_tree_t var(result);
According to documentation in library of boost.variant, a variable var
it's ( 1 ( 3 5 ) 7 ).

system ("ssh IP Port UserN PassW");    //may not work: can't input variables this way?
system ("scp /bin/bash/Sscript  IP:/bin/bash");
system ("ssh IP: chmode 700 /bin/bash/Sscript");
system ("ssh IP: /bin/bash/Sscript");   



	//alldevices = Utils::FileList(ExeDirectory() + "Devices");
	//Utils::TrimExtension(alldevices, ".txt");
	//for(UINT i=0; i< alldevices.size(); i++)
	//	allDevicesComboList.Add(alldevices[i].c_str());


//http://msdn.microsoft.com/en-us/library/6k3ybftz.aspx 
/**
* A simple INI file parser based on the NVP Query parser from:
* <a href="http://spirit.sourceforge.net/home/?p=371"></a>
* 
* This parser is used to parse ini files of the following below, 
* placing results on a std::map<std::string, std::string>:
*
*    key1=AnotherValue1 
*
*    # comment
*    key2=Value2
*    key3 =Value3 
*    key4 = Value4
*/


#define BOOST_SPIRIT_AUTO 

#include <boost/spirit/include/qi.hpp>
#include <boost/fusion/include/std_pair.hpp>
#include <boost/spirit/include/support_istream_iterator.hpp>


namespace spirit = boost::spirit;
namespace qi = boost::spirit::qi;
namespace ascii = boost::spirit::ascii;

// ----------------------------------------------------------------------------|


struct JsonMember;   ///< Forward declaration of JsonObject

/**
* Declare JsonValue as a bopost variant.
*
* Note: boost::recursive_wrapper is used to allow the JsonValue to
*       include a vector of JsonMember which has been forward
*       declared.
*
* Note: boost::make_recursive_variant is used to allow the JsonValue to
*       include a vector of JsonValue.
*
* TODO: Add support for NULL, possibly via a NullType.
*/
typedef boost::make_recursive_variant< bool
	, double
	, std::string
	, boost::recursive_wrapper< std::vector< JsonMember > >
	, std::vector< boost::recursive_variant_ >
>::type JsonValue;

/**
* Structure for parse Json members.
*/                      
struct JsonMember
{
	std::string name;    ///< the name of the member
	JsonValue   value;   ///< the value of the member

	/** constructor */
	JsonMember() : name()
		, value()
	{}

	/**
	* Convenience constructor.
	*
	* \param nm the name of the member.
	* \param val the value for the member.
	*/
	JsonMember( const std::string& nm, const JsonValue& val )
		: name(nm)
		, value(val)
	{}
};

/** Convenience typedefs. */
typedef std::vector<JsonMember> JsonObject;

// ---------------------------------------------------------------------------|
/** 
* Adapt the JsonMember structure using boost::fusion so that it can
* be used with boost::spirit::qi.
*/
BOOST_FUSION_ADAPT_STRUCT( JsonMember, ( std::string, name )
	( JsonValue, value ) )


	/** Type of results produced */

	// ----------------------------------------------------------------------------|
	/**
	* The Qi Grammar for the parser.
	*
	* \tparam Iterator the type of iterator the parser uses.
	* \tparam Skipper the skipper, for skipping over comments and whitespace.
	*/
	template <typename Iterator, typename Skipper>
struct key_value_sequence : qi::grammar< Iterator , NVPMapT() , Skipper >
{
	key_value_sequence() : key_value_sequence::base_type( nvp_map )
	{
		nvp_map = *entry;
		entry = pair | section ;
		pair  =  key >> '=' >> ( value | quotedString );
		key   =  qi::char_("a-zA-Z_") >> *qi::char_("a-zA-Z_0-9");
		//value = +qi::char_("a-zA-Z_0-9") >> eol_p;
		value = *(qi::char_ - "\n") >> "\n"; 
		quotedString = '\"' >> qi::lexeme[+(qi::char_ - '\"')] >> '\"' >> qi::eol;
		section  =  key >> '{' >>  "\n"  >> *(entry) >> "}" >> "\n";
	}
	qi::rule<Iterator, std::string(), Skipper> nvp_map;
	qi::rule<Iterator, NVPMapT(), Skipper> entry;
	qi::rule<Iterator, std::pair<std::string, std::string>() > pair;
	qi::rule<Iterator, std::pair<std::string, std::string>() > section;
	qi::rule<Iterator, std::string()> key;
	qi::rule<Iterator, std::string()> value;
	qi::rule<Iterator, std::string()> quotedString;
};

// ----------------------------------------------------------------------------|
/**
* Parse the supplied input.
*
* \tparam Input the type of input to parse.
* \param in the input to parse.
* \param storage storage for the parsed values.
* \return true if parsing was successful.
*/
template< class Input >
bool parse( Input& in, NVPMapT& storage )
{
	Input::iterator iter = in.begin();
	Input::iterator end = in.end();

	auto skipper =  ascii::space | '#' >> *(qi::char_ - qi::eol) >> qi::eol;
	typedef decltype( skipper ) skipper_type;

	client::key_value_sequence<std::string::iterator, skipper_type> parser;

	bool r = phrase_parse(iter, end, parser, skipper, storage);
	return (r && iter == end);
}